#version 330 core

layout (points) in;
layout (points, max_vertices = 30) out;

in float PType[];
in vec2 PPos[];
in vec2 PVel[];
in vec2 PScale[];
in float PRot[];
in float PLife[];
in float PMaxLife[];

out float Type;
out vec2 Position;
out vec2 Velocity;
out vec2 Scale;
out float Rotation;
out float Life;
out float MaxLife;


/// Enum Defines \\\

#define EMITTER_TYPE 0.0f
#define PARTICLE_TYPE 1.0f
#define TRAIL_TYPE 1.0f

#define SHAPE_POINT	        0
#define SHAPE_CIRCLE_VOLUME 1
#define SHAPE_CIRCLE_EDGE   2
#define SHAPE_SQUARE_VOLUME 3
#define SHAPE_SQUARE_EDGE   4

/// Uniforms \\\

uniform float	dt;
uniform float	Time;

uniform float	EmitterLifetime;
uniform float	ParticleLifetime;
uniform float	ParticleLifetimeVariance;

uniform bool	IsLooping;

uniform vec2	StartingVelocity;
uniform vec2	StartingVelocityVariance;
uniform vec2	Acceleration;

uniform int		ParticlesPerEmission;
uniform float	EmissionRate;
uniform vec3	BurstEmission;			// (Amt Min, Amt Max, Reoccurance Rate)
uniform int		EmissionShape;
uniform vec2	EmissionShapeScale;

uniform vec2	EmitterPosition;

uniform sampler1D RandomTexture;


vec3 rand(float TexCoord)
{
    return texture(RandomTexture, 1.0f/(TexCoord+1) * (Time + dt) ).xyz;
}


vec2 NewParticlePosition(vec2 center, vec2 r)
{
	if(EmissionShape == SHAPE_POINT)
		return center;

	if(EmissionShape < SHAPE_SQUARE_VOLUME)
	{
		// random between 0-2pi
		float angle = (r.x + 0.5f) * 6.28318531;

		// Cirlce Edge
		if(EmissionShape == SHAPE_CIRCLE_EDGE)
			return center + vec2( EmissionShapeScale.x * cos(angle), EmissionShapeScale.y * sin(angle));

		// Circle Volume (Circle edge * random value between 0-1)
		return center + (r.y + 0.5f) * vec2( EmissionShapeScale.x * cos(angle), EmissionShapeScale.y * sin(angle));
	}

	// Square (Disabling volume/edge until needed because math)			//if(EmissionShape == SHAPE_SQUARE_VOLUME)
	return center + r * EmissionShapeScale;
}

void HandleEmitter()
{
	float currAge = PLife[0] + dt;

	// Emit this particle emitter
    Type = EMITTER_TYPE;
    Position = EmitterPosition;
    Velocity = PVel[0];
    Life = currAge;
    EmitVertex();
    EndPrimitive();


	// Handle Emission

	if(!IsLooping && currAge >= EmitterLifetime) 
	{
		// Kill emitter from emitting new particles
		return; 
	}

	// Standard Emission
	if(EmissionRate > 0.0f)
	{
		if ( int(currAge / EmissionRate) > int(PLife[0] / EmissionRate))
		{
			// Emit new particle(s)

			for(int i = 0; i < ParticlesPerEmission; i++)
			{
				vec3 r = rand(i)*2 - vec3(1,1,1);

				Type = PARTICLE_TYPE;
				Position = NewParticlePosition(PPos[0], r.xy);
				Velocity = StartingVelocity + vec2(StartingVelocityVariance.x * r.x, StartingVelocityVariance.y * r.y);
				Life = ParticleLifetime + ParticleLifetimeVariance * r.z;

				EmitVertex();
				EndPrimitive();
			}
		}
	}

	// Burst Emission
	if(BurstEmission.z > 0.0f)
	{
		if( int(currAge / BurstEmission.z) > int(PLife[0] / BurstEmission.z) )
		{
			float amt = rand(0).x * (BurstEmission.y - BurstEmission.x) + BurstEmission.x;
			for(int i = 0; i < amt; i++)
			{
				vec3 r = rand(i)*2 - vec3(1,1,1);

				Type = PARTICLE_TYPE;
				Position = NewParticlePosition(PPos[0], r.xy );
				Velocity = StartingVelocity + vec2(StartingVelocityVariance.x * r.x, StartingVelocityVariance.y * r.y);
				Life = ParticleLifetime + ParticleLifetimeVariance * r.z;

				EmitVertex();
				EndPrimitive();
			}
		}
	}
}

void HandleParticle()
{
	float currAge = PLife[0] - dt;

	if(currAge > 0) 
	{
		// Still alive, update then emit self
	
		Type = PType[0];
		Position = PPos[0] + PVel[0] * dt;
	    Velocity = PVel[0] + Acceleration * dt;
	    Life = currAge;
	    EmitVertex();
	    EndPrimitive();
		
		/*
		if(Trail && PType[0] == PARTICLE_TYPE)
		{
			Type = TRAIL_TYPE;
		    Life = TrailLifetime;
		    EmitVertex();
		    EndPrimitive();
		}
		*/
	}
}


void main()
{	
	if(PType[0] == EMITTER_TYPE)
	{
		HandleEmitter();
	}
	else
	{
		HandleParticle();
	}
}
